{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Resume - Tony Calleri Fran\u00e7a","text":"<p>Excelent software engineer and web developer.  Great at leading, good at managing.</p> <p>Note: Are you looking at a printed (or PDF) version of this resume?  Please use the online version at tonylampada.github.io. It's likely to be more up-to-date and there are a bunch of external links.</p>"},{"location":"#-things-that-matter-more","title":"-- Things that matter more.","text":""},{"location":"#0-contact-info-and-online-profiles","title":"0. Contact info and online profiles","text":"<ul> <li>email: tonylampada@gmail.com</li> <li>Phone number / Whatsapp * / Telegram: +55 12 981440013</li> <li>Facebook</li> <li>Github</li> <li>Stack Overflow</li> <li>Medium</li> <li>Wordpress</li> <li>Youtube</li> <li>Toptal (freelancer marketplace)</li> </ul> <p>Note: If you want a quick answer, Whatsapp is the way to go.</p>"},{"location":"#1-who-am-i","title":"1. Who am I","text":"<p>I am a Brazilian software engineer and have been programming professionally since 2000. My motto is \"solve problems and help people\". So if you're ever in a pinch and need some tech advice or help, feel free to find me on whatsapp and I'll do what I can to help.</p> <p>I'm easy to work with. I take my job very seriously but I prefer to work in more relaxed and playful environments, and I do what I can to provide that kind of environment to people who work with me.</p> <p>Last but not least, I'm a husband and father of an awesome couple of boys.</p>"},{"location":"#2-what-i-can-do","title":"2. What I can do","text":"<ul> <li>I can do other things but I have worked most of my life with web development and devops. My favorite stack for webdev is Postgres, AWS, Docker, Python, Django and Vue.js.</li> <li>I can put together modern web applications and scalably deploy them - in an automated fashion - to production environments in the cloud with zero downtime.</li> <li>I can organize the development proccess for your team, and apply the right tools to make development a breeze both for front-end and back-end.</li> <li>I can design and understand business processes, and I can help with project management and bring a set of management best practices that tends to make everyone deliver better results consistently.</li> <li>I can (and love to) teach/train people on back-end and front-end development and devops tools and practices and I try my best motivate and influence people to be better programmers.</li> </ul>"},{"location":"#3-what-i-cant-do","title":"3. What I can't do","text":"<ul> <li>Be a full time project manager. I love the building part too much for that.</li> <li>Write good, working CSS code  - a frustration that I hope I'll overcome some day. Right now I usually need a CSS-ninja to work with me.</li> </ul>"},{"location":"#4-what-do-i-like","title":"4. What do I like","text":"<p>I believe software is a form of art and I care a lot for the inner quality of the software I build. Things like unit testing, good architecture, well-designed APIs matter a lot to me.</p> <p>I'm passionate about open source, and education in technology.</p>"},{"location":"#5-things-i-did-that-you-can-see-online","title":"5. Things I did that you can see online","text":"<ul> <li>Jarvis - Like, GPTExec (below), but as a custom GPT (and it can run commands on any computer, not just your machine). Talk to it to get instructions on how to install the JarvisClient and get it working ;-)</li> <li>GPTExec - GPT in your terminal, but with the ability to run commands on it.</li> <li>Articles - Thoughts and ramblings about how to make programming better</li> <li>Evolutio - A website with free educational content for anyone who wants to learn to code.</li> <li>Djangular3 - A reusable web-project template using Django and AngularJS (README is in portuguese, but there's a setup instructions video in english as well)</li> <li>Djavue - Same as above, but with Django and Vue.js (pun intended :P). This served as the foundation on top of which Buser technology was built. The corresponding Djavue course on evolutio has been used for training developers ever since. </li> <li>tlvuestarter - A Vue.js starter template, featuring mock-apis and a component catalog.</li> <li>webgl_graphs - Playing with webgl (3D rendering in the browser). This toy-tool lets you see graphs in 3D that obey simple attraction/repulsion rules.</li> <li>Dicas do Lampada - My tech blog</li> <li>My youtube channel - Mostly webdev-related screencast tutorials</li> <li>Javascript for grownups - Recording of a 3h webinar teaching javascript to random people from different parts of the world.</li> </ul>"},{"location":"#-traditional-stuff","title":"-- Traditional stuff","text":""},{"location":"#6-education","title":"6. Education","text":"<p>Computer Engineering, graduated in 2003 Aeronautics Technological Institute \u2013 ITA</p>"},{"location":"#7-work-experience","title":"7. Work Experience","text":""},{"location":"#roboflow-since-mar2023","title":"Roboflow (Since Mar/2023)","text":"<p>Fullstack developer: Having left a good legacy of great engineering and a culture of autonomy+responsibility at Buser, I decided to start a new adventure.  This new role marks a lot of new beginnings for my career and my life. Jumping with my two feet on the remote work train. Working with an international team, on an international product, using english all the time. Going back to a position that\u2019s a lot more focused on applying and improving my hard skills!</p> <p>At Roboflow I'm helping to improve every industry by democratizing computer vision by doing what I do best: writing quality software that pushes forward the company's product and work system.</p>"},{"location":"#buser-dec2017-mar2023","title":"Buser (Dec/2017 - Mar/2023)","text":"<p>Bus travel mobile app. Helping people travel by half the price or with twice the comfort. Changing the landscape of intercity bus travel in Brazil.</p> <p>CTO and Principal Engineer: I was the first person hired by the founders. My mission was to build the first version of Buser's website to sell tickets online. I used Django, Vue.js, AWS, a continuous delivery pipeline with Gitlab. 100% inside my comfort zone. That part was a piece of cake. But the easy part ends there. Buser's rapid growth demanded that I quickly learned a new set of skills way far from what my career had prepared me for. Hiring people. Building teams. Training people. Managing people and projects. Negotiating with different stakeholders in an ever more complex environment. Then re-learn to do all that again, but remotely, because of COVID. And all that while building and mantaining a strong engineering culture of autonomy and responsibility - encouraging people to act and see themselves as \"problem solver first, programmer later\". Being Buser's CTO was the wildest ride on my career, and our engineering culture is an accomplishment I take most pride in.</p> <p>In may/2022 (Buser had ~550 people, ~140 in technology) I decided to step down as Buser's CTO in order to reconnect with my natural vocation and competence. This was only possible because my good friend Thiago Avelino accepted the challenge of being the executive leader that Buser needs at this time. As a principal engineer, my new mission is to help tech teams improve themselves and build great software - which is exactly what I love doing.</p>"},{"location":"#independent-consulting-part-time-jan2017-dec2018","title":"Independent consulting (part time, jan/2017 - dec/2018)","text":"<p>Some consulting here and there, on web development and devops</p> <p>Consultant: I'm helping companies set up their continuous integration / deployment pipeline, improve their infrascture to make them scalable, refactor their development environments to be more efficient, etc. Companies I helped so far: Jetsoft, Moneto, Quero bolsa</p>"},{"location":"#sta-spacetime-analytics-part-time-may2016-jun2018","title":"STA - Spacetime Analytics (part time, may/2016 - jun/2018)","text":"<p>Machine-learning-based products and services for decision making.</p> <p>Chief Architect, Platforms: STA uses artificial intelligence, geoprocessing and data science to solve hard problems that traditional IT companies cannot. Like, use historical data for climate and satellite pictures to predict how much sugar cane will be obtained in the next crop. I did learn a little bit of machine learning, data science and statistics, but my main work here was to build the platforms where complex, computational-intensive alghorithms run, and also provide web-interfaces where clients can get the results they need.</p>"},{"location":"#lance-otimo-part-time-jun2015-dec2019","title":"Lance \u00d3timo (part-time, jun/2015 - dec/2019)","text":"<p>Bid management platform for Google AdWords advertisers</p> <p>CTO/Developer: My friend and associate Rafael was already helping clients with Google Adwords optimization and, at first, using excel spreadsheets was fine. He anticipated that his business was going to grow and that was when he invited me to help \"productizing\" his process in the form of a web platform. I jumped in, he learned Python and reimplemented all of his spreadsheets in python scripts. I put it all together inside a web application that clients can now use to tweak parameters and get reports that provide marketing insights.</p> <p>Lance \u00d3timo runs on Python, Django, Postgres, AWS, Celery, and AngularJS.</p>"},{"location":"#ng-masters-mai2014-oct2015","title":"ng-masters (mai/2014 - oct/2015)","text":"<p>AngularJS online Training Course - a successful weekend project</p> <p>Instructor: During my work using AngularJS in QM\u00e1gico, I liked it so much that I decided I wanted to teach more people about it and as a result ng-masters was born. NG-masters was a 16h online course spread across 4 online webinars that happened on saturday or monday mornings.  A month before each cohort started I would phone everyone that had registered on the website, and tried to understand better their problems, their context, and how (and if) the course would be useful for them. It was an amazing experience.</p> <p>With ng-masters I had the privilege of touching the lives of ~120 people during 5 cohorts, and I still feel I learned more than I taught.</p>"},{"location":"#qmagico-apr2013-dec2016","title":"QM\u00e1gico (apr/2013 - dec/2016)","text":"<p>TechEd startup - S\u00e3o Jos\u00e9 dos Campos </p> <p>CTO/developer: Leading architect of the company\u2019s main product \u2013 the QM\u00e1gico platform - A Learning Management System based in AngularJS (lots of it), Appengine and Django. QMagico is the first \u201creal\u201d startup (with a kind of a Silicon Valley \u201cvibe\u201d) that I worked at. Besides all the programming and DevOps stuff I feel I was able to improve myself with new abilities, preparing and giving tech talks to the team (programmers and otherwise), helping set the company\u2019s engineering culture, and sometimes wearing a product manager hat.</p>"},{"location":"#p2d-and-touch-health-apr2009-apr2013","title":"P2D and Touch Health (apr/2009 - apr/2013)","text":"<p>Healthcare Information Systems Companies \u2013 S\u00e3o Jos\u00e9 dos Campos, </p> <p>Architect/developer: P2D and Touch were partner in business. At P2D, I was leading architect of the company\u2019s main product \u2013 \u201cP2D Prontuario Universal\u201d. I was responsible for designing the solutions for most of the complex problems involved when it comes to building a universal, internet based Electronic Health Record System. I was also responsible for creating and evolving the processes and tools for configuration management and continuous deployment. At Touch, I also acted as a software architect improving their product, tools and processes.</p>"},{"location":"#zilics-dec2007-apr2009","title":"Zilics (dec/2007 \u2013 apr/2009)","text":"<p>Healthcare Information Systems Company \u2013 S\u00e3o Jos\u00e9 dos Campos, </p> <p>Architect, manager, developer: When Zilics decided to create a new unit in Sao Jose dos Campos, they honored me with an invitation to be the unit\u2019s coordinator. I was responsible for ensuring our unit delivered results and met deadlines, not only as a team manager, but also as architect and developer. It was a great challenge, in a good way. Zilics developed Healthcare Information Systems that aimed to improve quality for the patient. Technology-wise, we used a lot of Java/Jee Technologies like JSF, JPA, Hibernate, Spring, JasperReports, and surprisingly fancy JavaScript/AJAX components. I also took a vital part in the development of an complex archetype-based medical records system.</p>"},{"location":"#stefanini-it-solutions-aug2007-to-dec2007","title":"Stefanini IT Solutions (aug/2007 to dec/2007)","text":"<p>IT services - S\u00e3o Jos\u00e9 dos Campos.</p> <p>Architect: Coordination of a team of interns to develop small modules of big web applications. Management, architecture, design, programming \u2013 a little bit of everything. Technologies and platforms involved: Struts, Hibernate, JPA, Javascript, AJAX, Spring, Maven, Continuum.</p>"},{"location":"#dresdner-kleinwort-apr2007-to-aug2007","title":"Dresdner Kleinwort (apr/2007 to aug/2007)","text":"<p>Investment Bank - S\u00e3o Paulo, </p> <p>Analyst: Development and maintenance of several financial applications. Technologies and platforms involved: Swing, JDBC, Oracle, Sybase, SQL Server, Posture.</p>"},{"location":"#ibm-may2005-apr2007","title":"IBM (may/2005 - apr/2007)","text":"<p>IT services - Hortol\u00e2ndia/SP</p> <p>Analyst: Many development and support activities using Java and Websphere technologies, reporting directly to clients and managers in the United States. Participation in the biannual IBM Disaster Recovery exercise, in New York.</p>"},{"location":"#telefonica-oct2004-mai2005","title":"Telefonica (oct/2004 - mai/2005)","text":"<p>Telephone Company - S\u00e3o Paulo / Buenos Aires</p> <p>Analyst: Plays vital role in \u201cGAUDI\u201d \u2013 International Deployment Project. GAUDI is an integration system to communicate legacy systems and the Oracle eBusiness Suite, using IBM Websphere technology.</p>"},{"location":"#compsis-mar2004-oct2004","title":"COMPSIS (Mar/2004 - Oct/2004)","text":"<p>Automotive and Information Technology \u2013 S\u00e3o Jos\u00e9 dos Campos,</p> <p>Analyst: Systems design and development.  Establishing the company\u2019s J2EE development architecture and applying it on a current project. Also responsible for the team\u2019s training and coaching.</p>"},{"location":"#brasil-telecom-feb2004-mar2004","title":"Brasil Telecom (Feb/2004 - Mar/2004)","text":"<p>Cell Phone Company - Bras\u00edlia, </p> <p>Analyst: Technical Specification of Brasil Telecom\u2019s virtual store. Responsible for acquiring requirement change inputs from the client and leading the development team. Technologies: J2EE &amp; Hibernate.</p>"},{"location":"#claro-aug2003-oct2003","title":"CLARO (Aug/2003 - Oct/2003)","text":"<p>Cell Phone Company - Rio de Janeiro</p> <p>Analyst: Development of Claro\u2019s virtual store. Technologies: J2EE &amp; Weblogic.</p>"},{"location":"#cits-jan2003-jul2003","title":"CITS - (Jan/2003 - Jul/2003)","text":"<p>International Center of Software Technology - Curitiba</p> <p>Computer Science Technician: Research and Development of MDE (Multidisciplinary Engine) \u2013 a CORBA based distributed system. Project developed using RUP.</p>"},{"location":"#embraer-april2002-september2002","title":"EMBRAER (April/2002 - September/2002)","text":"<p>Brazilian Plane Factory \u2013 S\u00e3o Jos\u00e9 dos Campos, </p> <p>Analyst: Assists in the development of the open source project FlightGear Flight Simulator (www.flightgear.org), enabling the use of FlightGear to simulate EMBRAER\u2019s planes. Technologies: C++ and Computer Graphics (OpenGL).</p>"},{"location":"#fundacao-casimiro-montenegro-filho-may2002-to-august2002","title":"Funda\u00e7\u00e3o Casimiro Montenegro Filho (may/2002 to august/2002)","text":"<p>ITA\u2019s institute of research and development \u2013 S\u00e3o Jos\u00e9 dos Campos, </p> <p>Software Engineer: Design and Implementation of the Registration Tax Receiving System of ITA\u2019s vestibule contest (SIS-RETIVE), using the Rational Solutions CASE tools.</p>"},{"location":"#boldcron-technologies-march2000-may2001","title":"Boldcron Technologies (march/2000 - may/2001)","text":"<p>Software development company \u2013 S\u00e3o Jos\u00e9 dos Campos, </p> <p>Designer/Programmer: Development of various Internet multi-user database applications. Internet \u201ccomposite picture\u201d construction system. An Internet tool to provide interaction between the viewer and the \u201cSociedade An\u00f4nima\u201d TV show. Developed for Globo.com (www.globo.com) Online games: Bingo and \u201cTruco\u201d (a four-people Brazilian card game). Developed for Bananagames.com (www.bananagames.com.br).</p>"},{"location":"articles/","title":"Articles","text":"<p>Some ramblings and thoughts about how to make programming better</p> <ul> <li>Good Architecture</li> <li>Plumbing and intelligence</li> <li>Software engineering - the mindset</li> </ul>"},{"location":"encanamento-e-inteligencia/","title":"Encanamento + Intelig\u00eancia: um mindset pr\u00e1tico para arquitetura de software","text":""},{"location":"encanamento-e-inteligencia/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>\u00c0 medida que eu fui ganhando experi\u00eancia construindo software, percebi uma distin\u00e7\u00e3o fundamental entre dois tipos c\u00f3digo, que, na minha cabe\u00e7a, eu chamo de: </p> <ul> <li>c\u00f3digo de \"encanamento\", vs</li> <li>c\u00f3digo de \"intelig\u00eancia\". </li> </ul> <p>Vou explicar essa dualidade porque eu acredito que ela ajuda ter um mindset de programa\u00e7\u00e3o que tende a gerar software de qualidade (*).</p> <p>(*) Software de qualidade: software que n\u00e3o tem muito bug e voc\u00ea consegue mudar de maneira indolor sem ter vontade de arrancar os cabelos.</p> <p>Da minha experi\u00eancia, em aplica\u00e7\u00f5es bem feitas, encontramos uma harmonia sutil entre o \"encanamento\" \u2014 esses canais e condutos que guiam o fluxo de dados, \u2014 e a \"intelig\u00eancia\"  \u2014 a l\u00f3gica e as funcionalidades que d\u00e3o vida ao sistema. </p> <p>Quando eu programo enxergando esses dois pap\u00e9is no c\u00f3digo que t\u00e1 na minha frente, eu sinto que estou \"dominando os segredos\" da boa arquitetura, e de fato o software resultante tem menos acoplamento, mais coes\u00e3o, n\u00e3o viola o DRY, enfim, tem mais qualidade (*).</p> <p>E o mais importante: muitos dos problemas de qualidade que eu vejo aparecem quando a gente mistura encanamento + intelig\u00eancia no mesmo lugar. Ent\u00e3o enxergar essa distin\u00e7\u00e3o \u00e9 importante justamente pra gente evitar cair nas armadilhas de misturar esses dois tipos de coisa.</p> <p>Ent\u00e3o vamo l\u00e1.</p>"},{"location":"encanamento-e-inteligencia/#2-encanamento-vs-inteligencia-o-que-eu-quero-dizer-com-isso","title":"2. Encanamento vs Intelig\u00eancia: O que eu quero dizer com isso","text":"<p>Encanamento s\u00e3o aquelas partes do c\u00f3digo que basicamente levam dados de um lugar pra outro. Por exemplo:</p> <ul> <li>Um entrypoint que chama um servi\u00e7o</li> <li>Uma configura\u00e7\u00e3o de roteamento</li> <li>Um adapter que fala com uma API externa</li> <li>Um cat\u00e1logo de componentes de front-end</li> </ul> <p>\u00c9 c\u00f3digo simples, \"boring\", repetitivo. Mas nem por isso ele \u00e9 menos importante. Pro projeto de software, esse tipo de c\u00f3digo funciona como: </p> <ul> <li>um esqueleto - que define a forma e a estrutura do \"organismo\"</li> <li>um sistema circulat\u00f3rio - canais por onde os dados fluem, conectores que unem diferentes m\u00f3dulos</li> </ul> <p>Intelig\u00eancia s\u00e3o aquelas partes do c\u00f3digo onde fica a l\u00f3gica de neg\u00f3cio, as tomadas de decis\u00e3o, as regras espec\u00edficas ao dom\u00ednio de aplica\u00e7\u00e3o. \u00c9 o n\u00facleo que confere prop\u00f3sito ao sistema. Por exemplo:</p> <ul> <li>A implementa\u00e7\u00e3o das regras de neg\u00f3cio em um backend</li> <li>Componentes interativos de frontend</li> <li>\"Stores\" de estado reativo pra frontend (t\u00edpico de apps React ou Vue.js)</li> </ul> <p>Esses peda\u00e7os de c\u00f3digo s\u00e3o os \u00f3rg\u00e3os do sistema: o cora\u00e7\u00e3o, o pulm\u00e3o, o intestino. Cada \u00f3rg\u00e3o tem uma fun\u00e7\u00e3o diferente e espec\u00edfica e regras bem particulares de como ele funciona. \u00c9 atrav\u00e9s da a\u00e7\u00e3o desses \u00f3rg\u00e3os que a gente implementa o prop\u00f3sito do sistema.</p> <p>Bom, isso \u00e9 a id\u00e9ia geral. Mas talvez ainda esteja abstrato demais. Ent\u00e3o eu vou dar um exemplo tangibilizando como a gente aplica isso num backend.</p>"},{"location":"encanamento-e-inteligencia/#3-tangibilizando-backend-em-tres-camadas","title":"3. Tangibilizando: Backend em tr\u00eas camadas","text":"<p>Eu gosto de pensar em backend nestas 3 camadas:</p> <p></p> <p>Repare que isso \u00e9 \"um\" jeito \u2013 n\u00e3o necessariamente \"o\" jeito \u2013 de aplicar essa divis\u00e3o em um backend. Mas \u00e9 um jeito que eu acho que funciona bem pra grande maioria dos casos e eu recomendo usar isso na falta de um bom motivo pra n\u00e3o.</p> <p>Camada 1: Superf\u00edcie</p> <p>A camada da Superf\u00edcie \u00e9 o ponto de contato inicial no backend. S\u00e3o os \"entry-points\". Ela lida com as requisi\u00e7\u00f5es externas chama uma regra de neg\u00f3cio e manda a resposta no formato adequado. Puro \"Encanamento\". O foco \u00e9  direcionar as solicita\u00e7\u00f5es para os servi\u00e7os corretos.</p> <p>Responsabilidades:</p> <ul> <li>Saber qual m\u00e9todo de neg\u00f3cio chamar.</li> <li>Valida\u00e7\u00e3o b\u00e1sica de dados de entrada.</li> <li>Implementa\u00e7\u00e3o de seguran\u00e7a.</li> <li>Observabilidade e tratamento de erros imprevistos.</li> </ul> <p>A Superf\u00edcie n\u00e3o deve conter l\u00f3gica de neg\u00f3cios. Os m\u00e9todos dessa camada normalmente s\u00e3o curtos porque apenas delegam a execu\u00e7\u00e3o para algum servi\u00e7o. As responsabilidades \"secund\u00e1rias\" de seguran\u00e7a, valida\u00e7\u00e3o e observabilidade devem ser implementadas preferencialmente na forma de middlewares, decorators, ou \"helper functions\" de maneira que seja f\u00e1cil ativar/desativar essas regrinhas que ficam \"na frente\" ou \"ao redor\" da implementa\u00e7\u00e3o.</p> <p>Camada 2: Servi\u00e7os</p> <p>Os Servi\u00e7os s\u00e3o o cora\u00e7\u00e3o da \"Intelig\u00eancia\" no backend. Esta camada cont\u00e9m a l\u00f3gica de neg\u00f3cios essencial e \u00e9 respons\u00e1vel por executar as opera\u00e7\u00f5es centrais do sistema.</p> <p>Responsabilidades:</p> <ul> <li>Execu\u00e7\u00e3o da l\u00f3gica de neg\u00f3cios principal.</li> <li>Tomada de decis\u00f5es com base nos dados fornecidos.</li> <li>Interagir com outras partes do sistema para realizar tarefas.</li> </ul> <p>Os servi\u00e7os devem ser preferencialmente stateless e focados na execu\u00e7\u00e3o de tarefas espec\u00edficas. Servi\u00e7os: </p> <ul> <li>Confiam na camada de Superf\u00edcie para a entrega de dados consistentes e confi\u00e1veis. </li> <li>Dependem de Adapters para tomar a\u00e7\u00f5es que t\u00eam efeitos no \"mundo externo\".</li> </ul> <p>Servi\u00e7os n\u00e3o devem se incomodar com os detalhes de como falar com um banco de dados ou uma API externa. Eles usam adapters pra isso. Servi\u00e7os tamb\u00e9m n\u00e3o devem tentar tratar erros imprevistos. Eles s\u00f3 se incomodam em tratar erros que fazem parte do funcionamento previsto da aplica\u00e7\u00e3o. Qualquer erro imprevisto que acontecer vai ser tratado de maneira gen\u00e9rica pela camada de Superf\u00edcie.</p> <p>Camada 3: Adapters</p> <p>Os Adapters s\u00e3o a outra ponta do \"Encanamento\". Eles servem como intermedi\u00e1rios entre os Servi\u00e7os e os recursos externos ou internos do sistema, como bancos de dados, sistemas de mensageria ou APIs de terceiros.</p> <p>Responsabilidades:</p> <ul> <li>Conex\u00e3o com bancos de dados e execu\u00e7\u00e3o de consultas.</li> <li>Comunica\u00e7\u00e3o com APIs externas.</li> <li>Transforma\u00e7\u00e3o de dados entre formatos esperados pelos Servi\u00e7os e formatos externos.</li> <li>Tradu\u00e7\u00e3o de erros da API externa pra exce\u00e7\u00f5es customizadas</li> </ul> <p>Os Adapters isolam a complexidade das integra\u00e7\u00f5es externas, permitindo que os Servi\u00e7os se mantenham focados na l\u00f3gica de neg\u00f3cios.</p>"},{"location":"encanamento-e-inteligencia/#4-falar-e-facil-mostra-o-codigo-ai","title":"4. Falar \u00e9 f\u00e1cil. Mostra o c\u00f3digo a\u00ed","text":"<p>Aqui um exemplo de como isso fica numa aplica\u00e7\u00e3o em node/express com firebase.</p> <p>Vamos olhar primeiro pro \"jeito ruim\". O exemplo aqui \u00e9 um endpoint de autentica\u00e7\u00e3o com login e senha que tenta dar match no banco com um hash da senha, e devolve um token secreto tempor\u00e1rio associado ao usuario.</p> <pre><code>//no layers. Plumbing + intelligence blended and scrambled together\nconst admin = require('firebase-admin');\nconst db = admin.firestore();\nconst {hash, randomToken} = require('some-crypto-thing')\nconst cache = {};\n\n\napp.post('/api/login', async (req, res) =&gt; {\n   try {\n       const { login, password } = req.body;\n       if (!login || !password) {\n           console.warn(`/api/login status=400 bad input`);\n           return res.status(400).\n               json({ error: 'Login and password are required' });\n       }\n       const collection = db.collection('users');\n       const snapshot = await collection.\n           where('login', '==', login).\n           where('password', '==', hash(password)).get();\n       if (snapshot.empty) {\n           console.warn(`/api/login status=401 auth failed`);\n           res.status(401).json({ error: 'Authentication failed' });\n       } else {\n           const user = snapshot.docs[0].data();\n           const token = randomToken()\n           cache[token] = user; //in-memory for simplicity. could be Redis or something\n           console.log(`/api/login status=200 OK`);\n           res.status(200).json({\n               message: 'Authentication successful',\n               token: token\n           });\n       }\n   } catch (err) {\n       console.error(`/api/login - Error: ${err.message}`);\n       res.status(500).send('Unknown server error');\n   }\n});\n</code></pre> <p>Isso a\u00ed \u00e9 o \"mau exemplo\" do encanamento (tratamento da requisi\u00e7\u00e3o HTTP, acesso ao BD) misturado com a intelig\u00eancia (a regra de neg\u00f3cio que diz que \"voc\u00ea s\u00f3 passa daqui com a senha correta\")</p> <p>Olha s\u00f3 o monte de problema aqui:</p> <ul> <li>Voc\u00ea vai mesmo querer ficar logando console.log(\"status=blah\") em todo request handler?</li> <li>E esse try-catch gigante, tamb\u00e9m?</li> <li>N\u00e3o tem a menor chance de voc\u00ea conseguir reusar essa l\u00f3gica de neg\u00f3cio de autentica\u00e7\u00e3o sem duplicar c\u00f3digo.</li> <li>O conhecimento de como acessar o banco de dados tamb\u00e9m vai ficar espalhado em tudo que \u00e9 request handler.</li> </ul> <p>Enfim. Eu n\u00e3o gosto disso a\u00ed n\u00e3o. \u00c9 o tipo de c\u00f3digo que \u00e9 at\u00e9 r\u00e1pido de criar, mas que dificulta o reuso, dificulta o DRY e \u00e9 lento de mudar \u00e0 medida que a aplica\u00e7\u00e3o cresce.</p> <p>Eu mudaria isso da seguinte forma:</p> <p>Camada 1 - Request handler (encanamento)</p> <p><pre><code>// surface: handling http requests for login\n// \"app\" is an express application\n// \"authenticationService\" is a service that knows how to authenticate users\n\napp.use(loggingMiddleware);\napp.use(handleUnknownErrorsMiddleware);\napp.post('/api/login', reqLogin);\n\nfunction loggingMiddleware(req, res, next) {\n   res.on('finish', () =&gt; {\n       console.log(`INFO: Method ${req.method} called at URL ${req.originalUrl} - Status: ${res.statusCode}`);\n   });\n   next();\n}\n\nfunction handleUnknownErrorsMiddleware(err, req, res, next){\n   console.error(`ERROR: An error occurred on method ${req.method} at URL ${req.originalUrl} - Error: ${err.message}`);\n   res.status(500).send('Server error occurred');\n}\n\nasync function reqLogin(req, res){\n   const { login, password } = req.body;\n   if (!login || !password) {\n       return res.status(400).json({ error: 'Login and password are required' });\n   }\n   const result = await authenticationService.authenticate(login, password);\n   if (result.success) {\n       res.status(200).json({ message: 'Authentication successful', token: result.token });\n   } else {\n       res.status(401).json({ error: 'Authentication failed' });\n   }\n}\n</code></pre> Lido com request e response. A l\u00f3gica pertence ao servi\u00e7o. O servi\u00e7o nem sabe o que \u00e9 request, response, ou status code. Observabilidade implementada em middlewares.</p> <p>Camada 2 - authenticationService (intelig\u00eancia)</p> <p><pre><code>// authenticationService\n\nconst {userDao, filters} = require('./adapters/databaseAdapter');\nconst {userByToken} = require('./adapters/cacheAdapter')\nconst {isEqual} = filters\nconst {hash, randomToken} = require('some-crypto-thing')\n\nasync function authenticate(login, password) {\n   const user = await userDao.findWhere([isEqual(\"login\", login), isEqual(\"password\", hash(password))]);\n   if (user) {\n       const token = randomToken()\n       await userByToken.set(token, user)\n       return { success: true, token: token }; // Exemplo de token\n   } else {\n       return { success: false };\n   }\n}\n\nasync function getUserByToken(token) {\n   // exercise. think about it.\n}\n\nmodule.exports = {\n   authenticate,\n   getUserByToken\n};\n</code></pre> Conhe\u00e7o a regra pra autenticar o usuario. Orquestro diferentes adapters pra implementar tarefas mais baixo n\u00edvel.</p> <p>Camada 3 - databaseAdapter (encanamento)</p> <p><pre><code>// databaseAdapter.\n\nconst admin = require('firebase-admin');\nconst db = admin.firestore();\n\nclass BaseDao {\n   constructor(collectionName) {\n       this.collection = db.collection(collectionName);\n   }\n\n   async findWhere(conditions) {\n       let query = this.collection;\n       for (const condition of conditions) {\n           query = query.where(condition.field, condition.operator, condition.value);\n       }\n       const snapshot = await query.get();\n       if (snapshot.empty) {\n           return null;\n       }\n       let results = [];\n       snapshot.forEach(doc =&gt; results.push({ id: doc.id, ...doc.data() }));\n       return results.length === 1 ? results[0] : results;\n   }\n}\n\nconst filters = {\n   isEqual(field, value){\n       return {field, operator: '==', value}\n   },\n   // isGreater, isLess, ...\n}\n\nmodule.exports = {\n   userDao: new BaseDao(\"users\"),\n   filters: filters\n};\n</code></pre> Sei falar com o firestore (pra que servi\u00e7os n\u00e3o precisem saber). \"admin.firestore()\" n\u00e3o \u00e9 chamado em nenhum outro lugar. Servi\u00e7os n\u00e3o se incomodam em saber COMO falar com o banco de dados (ou storage, ou cache, ou APIs externas). Ent\u00e3o quando essas coisas mudam, n\u00e3o \u00e9 doloroso e ningu\u00e9m precisa arrancar o resto dos cabelos.</p> <p>\u00c9 isso. Espero que tenha achado essas id\u00e9ias \u00fateis.  At\u00e9 a pr\u00f3xima \ud83d\ude42</p>"},{"location":"good-architecture/","title":"Good architecture","text":"<p>Sometimes we know something but we don't know that we know them.  Or we just forget to apply what we already know in our daily lives.  This doc is more of a reminder (instead of a lecture) of one such thing.</p>"},{"location":"good-architecture/#good-architecture","title":"Good Architecture","text":""},{"location":"good-architecture/#what-is-good-architecture","title":"What is good architecture?","text":"<p>Software has good architecture when it's inexpensive and painless to change or increment its behavior.  As a bonus, well architected software tends to be much more reliable and bug-free.</p>"},{"location":"good-architecture/#why-does-it-matter","title":"Why does it matter?","text":"<p>The world is constantly moving beneath our feet.  Therefore we need to keep forever changing our software to adapt to it.  Doing that painlessly and inexpensively is good for business.  Having reliable software that doesn't break also boosts the reputation of whoever made it, and that is also good for business.  Business is a lot about trust after all.</p>"},{"location":"good-architecture/#how-do-we-achieve-good-architecture","title":"How do we achieve good architecture?","text":"<p>That is the \"million dollar question\" that I try to answer here so keep on reading.  But there's a few concepts and ideas we need to establish first, like \"cognitive load\", \"tech debt\" and \"management style traps\".</p>"},{"location":"good-architecture/#cognitive-load","title":"Cognitive load","text":"<p>When we build software, we need to think about a lot of things.  How is this going to behave?  What stuff is available for me to reuse?  How is this gonna impact other parts of the whole? All that thinking takes up space in your brain - which is limited.  That is cognitive load.  I guess we can think of cognitive load as \"the amount of brain RAM required to do something\".</p> <p>High cognitive load is a strong indicator of bad architecture (and usually a precursor to bugs).  Well architected software is made of \"pieces\" that have a well defined responsibility and are not too \"tangled up\" with other pieces,  so you can change each piece without having to think too much about possible unintended side effects.</p>"},{"location":"good-architecture/#tech-debt","title":"Tech debt","text":"<p>This is part of the \"laws of physics\" of building software.  I guess it's more or less like the second law of thermodynamics:  something like \"entropy will grow unless you spend some energy to prevent that\".</p> <p>We developers are able to take \"unhealthy shortcuts\" to build stuff. The situation is like: you have something to build and it's going to take a couple of days to finish it properly,  but for some reason you have to (or you think you have to) deliver it today.  Many times, we do know how to pull that off.  Developers have the amazing ability to BORROW EFFICIENCY FROM THE FUTURE!  This means we can be more efficient today (and maybe meet our deadline),  but that will necessarily come at the price of being less efficient in the future (hence, \"debt\").  This usually results in a piece of badly architected software (cheap to create today, expensive to change tomorrow). We can pay that debt later by going back to that code and rewriting it in a better way.  And if we do, it's all good.  But if we don't, the size of the debt tends to grow with time.  So the tech debt is the kind of debt that comes with some unknown interest rate.</p> <p>An example, just to clarify. Classic DRY* violation.</p> <ul> <li>DRY - Don't Repeat Yourself</li> </ul> <p>You have this\u2026</p> <p></p> <p>And then comes in a new requirement to support paypal as a new payment type.  Needs to be live yesterday. So we quickly do this.</p> <p></p> <p>Quick and dirty. </p> <p>Not needing to touch (and test) existing processPayment code is \"quick\" - also, we are lazy bastards who hate having to test the same things over and over again.</p> <p>Duplicating \"apply discount\" logic (and possibly payment error-handling logic) is \"dirty\".</p> <p>This is a tech debt. We need to go back later and fix this.  If we don't, then later someone else will follow that same bad,  code-duplicating pattern when we need a third payment method  (and that will increase the debt amount - this is the interest rate we talked about).</p> <p>Here's a metaphor to remember: Codebase = planet. Tech debt = baobabs. You = little prince.</p> <p> The little prince baobabs metaphor. There are many baobabs in life. Tech debt is one of them.</p>"},{"location":"good-architecture/#broken-windows","title":"Broken windows","text":"<p>\"Broken Windows\" is a theory about crime developed by sociologists in the 1980s.  A gross oversimplification of it is: \"vandalism is contagious\".  And there is a direct link between the broken windows findings and the social dynamics of tech debt when building software as a team.  The harsh truth is that you won't care about tech debt if everyone else doesn't either. It's harsh, but it's true.</p>"},{"location":"good-architecture/#two-traps","title":"Two Traps","text":"<p>Regardless of religion, this is also true for software development \ud83d\ude42. There are many \"bad ways\" and a few \"good ways\".  One relevant example is the balance between prioritizing \"value work\" and \"quality work\" -  I hate to put it like this because it kind of creates a false dichotomy of \"quality vs speed\"  and I really believe that quality leads to speed - but the spectrum exists nevertheless, and both ends of that spectrum are traps.</p>"},{"location":"good-architecture/#1-the-rewrite-trap","title":"1. The rewrite trap","text":"<p>\"New tech [insert shiny technology here] just came out and it's awesome!  Let's migrate a bunch of our stuff to use that!</p> <p>Or</p> <p>\"We have a bad codebase, let's throw it out and do a fresh start\"</p> <p>Those are bad choices. </p> <ul> <li>a) technology choice is meant to fulfill business needs, not developers' high-tech fantasies. And </li> <li>b) if that \"bad codebase\" supports your business (as in there are clients paying to use it), it's not \"bad\" at all. Grow up and have some love and respect for it! \ud83d\ude42. That \"bad\" codebase keeps the business healthy and supports us so we can continue to learn and do new cool things.</li> </ul> <p>Having fallen into those traps myself, all the times I did, I later realized that it wasn't the code that was bad.  It was I that was bad at refactoring! \ud83d\ude2c</p>"},{"location":"good-architecture/#2-the-shipshipship-trap","title":"2. The \"SHIPSHIPSHIP!\" Trap","text":"<p>The rewrite trap is like, the \"0 value, 100 quality\" end of the spectrum. Put purely technical people in charge of management, and you might fall into it. </p> <p>The \"SHIPSHIPSHIP\" trap is the opposite (and more commonly seen in the wild, maybe if you have super business-oriented product managers with no tech skills driving everyday prioritization).</p> <p>By demanding a continuous flow of fast deliveries, we risk incentivizing the creation of tech debt that most likely won't get paid. Do that for long enough and trap #1b will start to look attractive!</p> <p>So, it's a balance. We need to chop trees, and for that we need to sharpen our axes. Spend your whole life sharpening your axe and you never get any tree down. Chop trees all the time and your ax will get dull, which you'll get tired. That's no good either. </p> <p>The way to go is to do both: keep chopping trees, and always be making sure you have a sharp axe. For software, this means that: we set the quality standards (which is usually higher than what we currently have), then keep moving forward and upward. </p> <p>Once we reach it, we keep moving forward and oscillating around it. The ground might move beneath our feet and we might need to change that target up or down, and that is ok too (example: the Facebook motto that went from \"move fast and break things\" to \"move fast with stable infra\").</p>"},{"location":"good-architecture/#good-architecture-how-to-create-it","title":"Good architecture - how to create it","text":"<p>So, back at the million dollar question, here's an attempt to answer it:</p> <p>You do two things.</p>"},{"location":"good-architecture/#1-set-the-culture","title":"1. Set the Culture","text":"<p>The first, most important thing (like, say, 80% importance), is to: cultivate a good engineering culture. As team members we should agree that we all care deeply about ~our planet~ the quality of our codebase and will do our best to get rid of ~baobabs~ high cognitive load and tech debt. Leaders should send strong messages about the importance of good architecture and how it is aligned with business and professional success.</p>"},{"location":"good-architecture/#2-set-the-standards","title":"2. Set the Standards","text":"<p>If we have #1, everyone kinda wants the same things, all that's left is \"just work.  We gotta define what we mean by good/bad architecture.  Think about generic guidelines that will have a tendency to reduce cognitive load and keep tech debt at bay. You can see further on giant's shoulders:  DRY,  KISS,  YAGNI,  The 12 factors,  Low coupling / high cohesion,  are all ideas and frameworks you can and should pick and adapt to your context.</p> <p>Then write it down, give some examples.  Cultivate a set of \"living documents\" that is continuously consulted and updated with new standards we want to implement, antipatterns we want to avoid, etc.  That will serve as a guide to orient team members to gradually improve code quality whenever they touch it.  Team members can reference it in code review conversations, etc.</p> <p>Those two things reinforce each other.  It's like #1 we want the same things and #2 we speak the same language, like a tribe!  You need #1 to start the spark and then then you need #2 to fuel the fire and keep it burning. </p>"},{"location":"plumbing-and-intelligence/","title":"Plumbing + Intelligence: A Practical Mindset for Software Architecture","text":""},{"location":"plumbing-and-intelligence/#1-introduction","title":"1. Introduction","text":"<p>As I gained experience in building software, I realized a fundamental distinction between two types of code, which in my mind, I refer to as:</p> <ul> <li>\"plumbing\" code, vs</li> <li>\"intelligence\" code.</li> </ul> <p>I want to explain this duality because I believe it assists in cultivating a programming mindset that tends to produce quality software (*).</p> <p>(*) Quality software: software that doesn't have a lot of bugs and can be modified ~~without wanting to pull your hair out~~ painlessly.</p> <p>From my experience, in well-crafted applications, we find a subtle harmony between \"plumbing\" \u2014 these channels and conduits that guide the flow of data, \u2014 and \"intelligence\" \u2014 the logic and functionalities that breathe life into the system.</p> <p>When I'm coding, seeing these two roles in the code in front of me makes me feel like I'm \"mastering the secrets\" of good architecture, and indeed the resulting software has less coupling, more cohesion, does not violate the DRY principle, in short, it has more quality (*).</p> <p>And most importantly: many of the quality issues I see arise when we mix plumbing and intelligence in the same place. Therefore, recognizing this distinction is crucial to avoid falling into the trap of mixing these two types of things.</p> <p>So, let's go.</p>"},{"location":"plumbing-and-intelligence/#2-plumbing-vs-intelligence-what-i-mean-by-this","title":"2. Plumbing vs Intelligence: What I Mean by This","text":"<p>Plumbing refers to those parts of the code that define the structure of the application AND move data from one place to another. For example:</p> <ul> <li>An entry point that calls a service.</li> <li>A routing configuration.</li> <li>An adapter that communicates with an external API.</li> <li>A catalog of front-end components.</li> </ul> <p>It's simple, \"boring\", repetitive code. But that doesn't make it any less important.  For a software project, this type of code functions both as:</p> <ul> <li>A skeleton - defining the shape and structure of the \"organism.\"</li> <li>A circulatory system - channels through which data flows, connectors that unite different modules.</li> </ul> <p>Intelligence is those parts of the code where business logic, decision-making, and domain-specific rules reside. For example:</p> <ul> <li>The implementation of business rules in a backend.</li> <li>Interactive frontend components.</li> <li>\"Stores\" of reactive state for frontend (typical in React or Vue.js apps).</li> </ul> <p>These pieces of code are the organs of the system: the heart, the lungs, the intestines.  Each organ has a different and specific function and particular rules about how it operates.  It's through the action of these organs that we implement the purpose of the system.</p> <p> (Here's how DALL-E sees this. That's a weird place for the heart, but it gets the job done)</p> <p>Well, that's the general idea, but it might still be too abstract.  So, I'm going to give an example to materialize how we apply this in a backend.</p>"},{"location":"plumbing-and-intelligence/#3-materializing-three-layer-backend","title":"3. Materializing: Three-Layer Backend","text":"<p>I like to think of backend architecture in these three layers:</p> <p></p> <p>Note that this is \"one\" way \u2013 not necessarily \"the\" way \u2013 to apply this division in a backend.  But it's a way that I find works well for the majority of cases and I recommend using it unless there's a good reason not to.</p> <p>Layer 1: Surface</p> <p>The Surface layer is the initial contact point in the backend. They are the \"entry-points.\"  It deals with external requests, calls a business rule, and sends the response in the appropriate format.  Pure \"Plumbing.\"  The focus is on directing requests to the correct services.</p> <p>Responsibilities:</p> <ul> <li>Knowing which business method to call.</li> <li>Basic validation of input data.</li> <li>Implementation of security.</li> <li>Observability and handling of unforeseen errors.</li> </ul> <p>The Surface should not contain business logic.  The methods in this layer are usually short because they only delegate execution to some service.  The \"secondary\" responsibilities of security, validation, and observability should preferably be implemented in the form  of middlewares, decorators, or \"helper functions\" so that it's easy to activate/deactivate these rules that are \"in front\"  or \"around\" the implementation.</p> <p>Layer 2: Services</p> <p>Services are the heart of \"Intelligence\" in the backend.  This layer contains the essential business logic and is responsible for executing the central operations of the system.</p> <p>Responsibilities:</p> <ul> <li>Execution of the main business logic.</li> <li>Making decisions based on the data provided.</li> <li>Interacting with other parts of the system to perform tasks.</li> </ul> <p>Services should preferably be stateless and focused on executing specific tasks. Services:</p> <ul> <li>Rely on the Surface layer for the delivery of consistent and reliable data.</li> <li>Depend on Adapters to take actions that have effects in the \"external world.\"</li> <li>Can also depend and orchestrate the execution of other services</li> </ul> <p>Services should not bother with the details of how to talk to a database or an external API. There are adapters for that.  Services also should not try to handle unexpected errors. They should handle only the errors that are part of the expected alternative business flows.  Any unexpected error that occurs will be handled generically by the Surface layer.</p> <p>Layer 3: Adapters</p> <p>Adapters are the other end of \"Plumbing.\"  They serve as intermediaries between Services and the external or internal resources of the system, such as databases,  messaging systems, or third-party APIs.</p> <p>Responsibilities:</p> <ul> <li>Connection to databases and execution of queries.</li> <li>Communication with external APIs.</li> <li>Transformation of data between formats expected by Services and external formats.</li> <li>Translation of external API errors into custom exceptions.</li> </ul> <p>Adapters isolate the complexity of external integrations, allowing Services to remain focused on business logic.</p>"},{"location":"plumbing-and-intelligence/#4-talk-is-cheap-show-me-the-code","title":"4. Talk is cheap. Show me the code","text":"<p>Here's an example of how this works in a Node/Express application with Firebase.</p> <p>Let's first look at the \"wrong way\". The example here is an authentication endpoint with login and password that tries to match it in the database with a password hash, and then returns a temporary secret token associated with the user.</p> <pre><code>//no layers. Plumbing + intelligence blended and scrambled together\nconst admin = require('firebase-admin');\nconst db = admin.firestore();\nconst {hash, randomToken} = require('some-crypto-thing')\nconst cache = {};\n\n\napp.post('/api/login', async (req, res) =&gt; {\n   try {\n       const { login, password } = req.body;\n       if (!login || !password) {\n           console.warn(`/api/login status=400 bad input`);\n           return res.status(400).\n               json({ error: 'Login and password are required' });\n       }\n       const collection = db.collection('users');\n       const snapshot = await collection.\n           where('login', '==', login).\n           where('password', '==', hash(password)).get();\n       if (snapshot.empty) {\n           console.warn(`/api/login status=401 auth failed`);\n           res.status(401).json({ error: 'Authentication failed' });\n       } else {\n           const user = snapshot.docs[0].data();\n           const token = randomToken()\n           cache[token] = user; //in-memory for simplicity. could be Redis or something\n           console.log(`/api/login status=200 OK`);\n           res.status(200).json({\n               message: 'Authentication successful',\n               token: token\n           });\n       }\n   } catch (err) {\n       console.error(`/api/login - Error: ${err.message}`);\n       res.status(500).send('Unknown server error');\n   }\n});\n</code></pre> <p>This here is the \"bad example\" of plumbing (handling the HTTP request, accessing the DB) mixed with intelligence (the business rule that says \"you shall only pass with the correct password\").</p> <p>Just look at the multitude of problems here:</p> <ul> <li>Do you really want to be logging console.log(\"status=blah\") in every request handler?</li> <li>What about this huge try-catch block, too?</li> <li>There's no way you can reuse this authentication business logic without duplicating code.</li> <li>Knowledge of how to access the database will also be scattered across every request handler.</li> </ul> <p>In short, I don't like this. It's the kind of code that might be quick to create, but it hinders reuse, violates the DRY principle, and is slow to change as the application grows.</p> <p>Here's how I would refactor it:</p> <p>Layer 1 - Request handler (plumbing)</p> <p><pre><code>// surface: handling http requests for login\n// \"app\" is an express application\n// \"authenticationService\" is a service that knows how to authenticate users\n\napp.use(loggingMiddleware);\napp.use(handleUnknownErrorsMiddleware);\napp.post('/api/login', reqLogin);\n\nfunction loggingMiddleware(req, res, next) {\n   res.on('finish', () =&gt; {\n       console.log(`INFO: Method ${req.method} called at URL ${req.originalUrl} - Status: ${res.statusCode}`);\n   });\n   next();\n}\n\nfunction handleUnknownErrorsMiddleware(err, req, res, next){\n   console.error(`ERROR: An error occurred on method ${req.method} at URL ${req.originalUrl} - Error: ${err.message}`);\n   res.status(500).send('Server error occurred');\n}\n\nasync function reqLogin(req, res){\n   const { login, password } = req.body;\n   if (!login || !password) {\n       return res.status(400).json({ error: 'Login and password are required' });\n   }\n   const result = await authenticationService.authenticate(login, password);\n   if (result.success) {\n       res.status(200).json({ message: 'Authentication successful', token: result.token });\n   } else {\n       res.status(401).json({ error: 'Authentication failed' });\n   }\n}\n</code></pre> Here I'm concerned with request and response. The logic belongs to the service. The service does not even know what request, response, or status code is. Observability implemented in middlewares.</p> <p>Layer 2 - authenticationService (intelligence)</p> <p><pre><code>// authenticationService\n\nconst {userDao, filters} = require('./adapters/databaseAdapter');\nconst {userByToken} = require('./adapters/cacheAdapter')\nconst {isEqual} = filters\nconst {hash, randomToken} = require('some-crypto-thing')\n\nasync function authenticate(login, password) {\n   const user = await userDao.findWhere([isEqual(\"login\", login), isEqual(\"password\", hash(password))]);\n   if (user) {\n       const token = randomToken()\n       await userByToken.set(token, user)\n       return { success: true, token: token }; // Exemplo de token\n   } else {\n       return { success: false };\n   }\n}\n\nasync function getUserByToken(token) {\n   // exercise. think about it.\n}\n\nmodule.exports = {\n   authenticate,\n   getUserByToken\n};\n</code></pre> I know the rule to authenticate the user. I orchestrate different adapters to implement lower-level tasks.</p> <p>Layer 3 - databaseAdapter (plumbing)</p> <p><pre><code>// databaseAdapter.\n\nconst admin = require('firebase-admin');\nconst db = admin.firestore();\n\nclass BaseDao {\n   constructor(collectionName) {\n       this.collection = db.collection(collectionName);\n   }\n\n   async findWhere(conditions) {\n       let query = this.collection;\n       for (const condition of conditions) {\n           query = query.where(condition.field, condition.operator, condition.value);\n       }\n       const snapshot = await query.get();\n       if (snapshot.empty) {\n           return null;\n       }\n       let results = [];\n       snapshot.forEach(doc =&gt; results.push({ id: doc.id, ...doc.data() }));\n       return results.length === 1 ? results[0] : results;\n   }\n}\n\nconst filters = {\n   isEqual(field, value){\n       return {field, operator: '==', value}\n   },\n   // isGreater, isLess, ...\n}\n\nmodule.exports = {\n   userDao: new BaseDao(\"users\"),\n   filters: filters\n};\n</code></pre> I know how to talk with Firestore (so that services don't need to). 'admin.firestore()' is not called anywhere else. Services do not bother knowing HOW to talk with the database (or storage, or cache, or external APIs). So when these things change, it's not painful and nobody needs to pull their hair out.</p> <p>That's it. I hope you found these ideas helpful. See you next time \ud83d\ude42</p>"},{"location":"the-mindset/","title":"Software Engineering: The Mindset","text":"<p>Before we think about software development good practices in a technical sense, I believe it's worth thinking about a \"higher-order\" good practice, which is approaching it with the right mindset. </p> <p>A \"contextualizing prompt\" for you to embody before you take action \ud83d\ude05.</p> <p>This article is a collection of tips that, in my experience help create thriving software projects.</p>"},{"location":"the-mindset/#1-tech-debt-pay-it-while-its-cheap","title":"1. Tech debt - pay it, while it's cheap.","text":"<p>You probably have some, right? Maybe left over from a not-so-distant past when you were sprinting to quickly build an MVP.</p> <p>But looking forward, to keep growing your software product and keep it healthy, you'll need good architecture,  good abstractions and revert the growing tendency of tech debt. </p> <p>This requires making a decision that, from this point onwards, we'll make sure debt only decreases.</p> <p>A good way to do that is to work on bug \ud83d\udc1e fixes!  Bugs are rarely the result of a single isolated problem.  Instead, they are usually the result of some deeper related debt around some functionality.  We should try to work on bugs in way that fixes them quickly first,  but then do a deeper critical analysis to understand what is the kind of debt that allowed that bug to exist,  and then work to decrease or maybe even eliminate that debt.</p>"},{"location":"the-mindset/#2-code-is-a-place","title":"2. Code is a place.","text":"<p>I'm sure you've felt it.  When you're \"in the zone\", code is not only a thing that you manipulate.  It becomes a space that surrounds your conscience, a place around you. </p> <p></p> <p>I saw this movie once about a regular guy who found a pill that made him super smart.  He lives alone in a messy apartment, and the very first thing he does when he's in \"super-smart mode\" is clean the place:  do the dishes, put out the dirty clothes lying around, take out the trash\u2026  It was like he knew he needed to clean the place in order to think straight. It blew my mind \ud83d\ude32\ud83d\ude32, I never forgot that.  \"The first thing you do when you're super smart is to make the space around you clean and organized\". This feels exactly right.</p>"},{"location":"the-mindset/#3-chaos-and-order","title":"3. Chaos and Order","text":"<p>I read once that our brain has two sides because we have evolutionarily adapted to an interesting aspect of reality:  the world is made of chaos and order, familiar and unfamiliar, explored and unexplored.  And our conscience is the process that transforms chaos into order. </p> <p>It's something like: When you're in the middle of chaos, at first you don't know what to do.  So you do nothing, you're paralyzed by chaos. </p> <p>But you're not doing nothing. You're paying attention. You're learning about this new unfamiliar environment.  Until you understand just enough to reorganize it a little bit. This is a seed of order. </p> <p>As you keep working in that seed, you change the once unfamiliar environment around you for the better,  you create an expanding domain of order out of chaos.</p> <p>As a programmer, you sure have lived through this process many times.  For example at first you may not have a clear idea of how state flows through a particular part of the code.  Then after studying, testing, debugging, you start to wrap your head around it.  And then your brain starts to poke you with ideas on how to improve that code somehow.</p> <p>Programmers should feel discomfort in chaos, but never feel intimidated by it, since you know how to thrive in it. </p> <p>You're an agent of order. A bringer of order through attention, learning, and work.</p>"},{"location":"the-mindset/#4-think-of-code-as-a-representation-of-knowledge","title":"4. Think of code as a representation of knowledge.","text":"<p>Not just a sequence of instructions.</p> <p>When we're learning how to code, code is just that: a sequence of instructions.  As we gather experience through the years and work on more complex systems, we realize that code should be more than that. </p> <p>Complex systems are made of smaller parts that know something, or know how to do something. It's very useful to think about building software as something analogous to organizing a tree of knowledge. </p> <p>We need to write code in a way that reveals our intentions - the what and the why (not only the how). We need to choose carefully in which branch of the tree each piece of knowledge should be hanging, in a way that knowledge is not duplicated and is available/connected to the other branches that need it. A good approach to code organization mindset is to think about it in terms of \"plumbing code and intelligence code\", and then avoid mixing those two types.</p>"},{"location":"the-mindset/#5-business-knowledge-tech-knowledge","title":"5. Business knowledge &gt; Tech knowledge","text":"<p>If we want our code to also be a representation of knowledge, then we must choose what kind of knowledge we want it to represent. </p> <p>There is knowledge about the technology - the how - and knowledge about the business - the what and the why. </p> <p>Our code should represent both, but the business knowledge should be primary and the technology knowledge secondary. </p> <p>More concretely, for example, let's say you have a software product for booking travels, the names of files, folders, variables, methods etc should \"shine\" things like {reservation, passenger, schedule, etc} brighter than things like {listeners, adapters, middlewares, triggers, endpoints, etc}. </p> <p>Technology and Business are both very important. And when representing knowledge as code, the business matters more. The vocabulary of the business should be the vocabulary of the tech.</p>"},{"location":"the-mindset/#6-every-improvement-counts","title":"6. Every improvement counts","text":"<p>You are part of a complex ever-evolving sociotechnical (people + technology) system. You are both an element that participates in that system's processes and a agent of change within that system. </p> <p>When you change the system for the better you should feel good about it, and when others do it we should celebrate and show appreciation for it. </p> <p>By doing that we encourage the kind of behavior that keeps steering the system to a better place.</p>"},{"location":"the-mindset/#7-compounding-interest-for-better-or-worse","title":"7. Compounding interest, for better or worse","text":"<p>We can all understand why tech debt is called \"debt\" - it has an interest rate, it grows if you don't pay it. Worse, it's compounding interest - the higher the debt, the quicker it grows. Yikes! \ud83d\ude31</p> <p>But, on the bright side, what is \"true for evil\" is also \"true for good\". For example a single new automated test might:</p> <ul> <li>prevent an old bug from ever surfacing again, </li> <li>create a piece of \"executable documentation\" for a module in the code</li> <li>allow the team to work on that feature faster next time</li> </ul> <p>The investments we make in quality will also produce ever growing dividends in the future.</p>"},{"location":"the-mindset/#8-self-documenting","title":"8. Self documenting","text":"<p>There's this idea that code should be self-documenting and shouldn't need any comments to explain it. That comments are like deodorant that \"disguise\" bad smell without getting rid of what's causing it. A comment is a failure to express yourself in code. If you fail, then write a comment; but try not to fail.\u00a0(Uncle Bob).</p> <p>I believe this idea is absolutely correct and even that it's generalizable for documentation in general. The best documentation is the one that you don't need to write, because it's already encoded in culture, and/or tools, and/or automation. People \"do the right thing\" either because it's automated, or because everyone else around them already do it, or because the tools in place makes it the easier path forward.</p> <p>For example a repository's README should have sections like:</p> <ul> <li> <ol> <li>What is this repo</li> </ol> </li> <li> <ol> <li>How to dev</li> </ol> </li> <li> <ol> <li>How to run tests</li> </ol> </li> <li> <ol> <li>How to deploy</li> </ol> </li> <li> <ol> <li>How to observe</li> </ol> </li> <li> <ol> <li>Internal architecture</li> </ol> </li> </ul> <p>But ideally the actual contents under those sections should be as short as possible like simply \"start the devcontainer and run <code>start.sh</code> or \"run <code>npm run test</code> from the root folder\".</p>"},{"location":"the-mindset/#9-code-reviews-3-reasons-why","title":"9. Code reviews: 3 reasons why","text":"<p>Code reviews are a great idea. It's no wonder everyone does it. And I think it's important to know why we do it. </p> <p>If you ask yourself why, the most likely reason that will come to mind is a) \"to proofcheck each other's work\". Indeed that's very important, we do catch a lot of bugs during CR before they make it to prod.</p> <p>But that's not the only reason. Here's two more: b) to share knowledge. Shared knowledge multiplies impact - you learn something nice and apply it somewhere else. It also de-risks having important company knowledge stored in just one head.</p> <p>And c) to standardize and converge. If we don't look at each other's code, we're a lot more likely to reinvent the wheel, to create different solutions to the same problems. Peeking at each other's work allows everyone to reuse and standardize solutions to problems.</p> <p>So, it's good to have those in mind when doing code reviews \ud83d\ude09.</p>"}]}